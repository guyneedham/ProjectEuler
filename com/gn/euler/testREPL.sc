package com.gn.multiplesOf3and5

import scala.annotation.tailrec


object testREPL {
                                                  
 /*
 Highly divisible triangular number
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
 */
 
 class TriangleNumbers {
 
 		var last = 0
 		var current = 1
 		var index = 1
 
 		def getNext: Int = {
      last = current
      index += 1
 			current = last + index
 			current
 		}
 
 }
 
 def getDivisors(n: Int): List[Int] = for (i <- List.range(1, math.sqrt(n).toInt) if n % i == 0) yield i // ns filter (n % _ == 0)//
                                                  //> getDivisors: (n: Int)List[Int]
 

 //def g(t: Int) = Range(1, Int.MaxValue).takeWhile(n => n * n <= t).toList
 //g(28)
 
 lazy val triangles: Stream[Int] =
  0 #:: triangles.zipWithIndex.map(n => n._1 + n._2 + 1)
                                                  //> triangles: => Stream[Int]
def p(t: Int) = Range(1, Int.MaxValue)
  .takeWhile(n => n * n <= t)
  .foldLeft(0)((s, n) => if (t % n == 0) s + 2 else s)
                                                  //> p: (t: Int)Int

//val r = triangles.find(p(_) > 500).get

//assert(r == 76576500) // 1 s
//countDivisors implementation 1:
//range to square root, for loop, multiply size by 2
//easy to reason about
//reduce runtime to something sensible by ranging from 1 to square root n, then double answer to count reciprocals
def countDivisors(n: Int) = (for (i <- (1 to math.sqrt(n).toInt) if n % i == 0) yield i).size * 2
                                                  //> countDivisors: (n: Int)Int

//countDivisors implemenation 2:
//more functional composition
//much harder to understand
def countDivisors2(t: Int) = Range(1, Int.MaxValue) //start with range of all numbers from 1
  .takeWhile(m => m * m <= t) //fiter until m^2 is less than t -- so up until square root t
  .foldLeft(0)((s, n) => if (t % n == 0) s + 2 else s) //foldLeft to do the count
                                                  //> countDivisors2: (t: Int)Int
                                                       //s = the value we have
                                                       //if the t modulo n is 0, it's a divisor
                                                       //increment count by 2, else leave it as it is
                                                       
def time[R](block: => R): R = {
    val t0 = System.nanoTime()
    val result = block    // call-by-name
    val t1 = System.nanoTime()
    println("Elapsed time: " + (t1 - t0) + "ns")
    result
}                                                 //> time: [R](block: => R)R


time { triangles.find(countDivisors(_) > 500).get }
                                                  //> Elapsed time: 1550051067ns
                                                  //| res0: Int = 76576500
time { triangles.find(countDivisors2(_) > 500).get }
                                                  //> Elapsed time: 1949279670ns
                                                  //| res1: Int = 76576500


// result = method 1 is repeatedly faster and also easier to understand
                                                  //                1128520272ns
                                                       
                                                       
//  countDivisors(28)
 // .foldLeft(0)((s, n) => if (t % n == 0) s + 2 else s)

//val r = triangles.find(countDivisors(_) > 500).get

//assert(r == 76576500)


 
}