package com.gn.euler

class TriangleNumberDivisors {
  
  /*
 Highly divisible triangular number
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
 */

  // stream of triangle numbers
  lazy val triangles: Stream[Int] =
  0 #:: triangles.zipWithIndex.map(n => n._1 + n._2 + 1) // next triangle number is previous number plus index (from 0) plus 1
  
//countDivisors implementation 1:
//range to square root, for loop, multiply size by 2
//easy to reason about
//reduce runtime to something sensible by ranging from 1 to square root n, then double answer to count reciprocals
def countDivisors(t: Int) = (for (i <- (1 to math.sqrt(t).toInt) if t % i == 0) yield i).size * 2
  
//countDivisors implementation 2:
//more functional composition
//much harder to understand
def countDivisors2(t: Int) = Range(1, Int.MaxValue) //start with range of all numbers from 1
  .takeWhile(m => m * m <= t) //fiter until m^2 is less than t -- so up until square root t
  .foldLeft(0)((s, n) => if (t % n == 0) s + 2 else s) //foldLeft to do the count
                                                       //s = the value we have
                                                       //if the t modulo n is 0, it's a divisor
                                                       //increment count by 2, else leave it as it is
  // helper function to profile code
  def time[R](block: => R): R = {
    val t0 = System.nanoTime()
    val result = block    // call-by-name
    val t1 = System.nanoTime()
    println("Elapsed time: " + (t1 - t0) + "ns")
    result
}   
  
  //val r = time { triangles.find(countDivisors(_) > 500).get }
  //val r1 = time { triangles.find(countDivisors2(_) > 500).get }
  
  // implementation 1 is repeatedly faster and also easier to understand
  // therefore used that implementation in function
  
  def firstTriangleWithAtLeastNDivisors(n: Int): Int = triangles.find(countDivisors(_) > n).get
  
  assert( firstTriangleWithAtLeastNDivisors(5) == 28 )
  
}